"""
Enhanced Reference Management API Endpoints

RESTful API endpoints for the enhanced reference management system.
Provides access to all system capabilities via HTTP API.

Linear Issues: ROS-XXX
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime
from fastapi import FastAPI, HTTPException, BackgroundTasks
from pydantic import BaseModel, Field
import uvicorn

from .reference_management_service import get_reference_service
from .integration_hub import get_integration_hub
from .collaborative_references import get_collaborative_manager, ReferenceEdit
from .journal_intelligence import get_journal_intelligence
from .monitoring import get_system_monitor
from .deployment_setup import deploy_enhanced_reference_system, validate_system_deployment
from .reference_types import ReferenceState, CitationStyle, Reference

logger = logging.getLogger(__name__)

# API Models
class ReferenceProcessingRequest(BaseModel):
    \"\"\"Request model for reference processing.\"\"\"
    study_id: str = Field(..., description=\"Study identifier\")
    manuscript_text: str = Field(..., description=\"Full manuscript text\")
    literature_results: List[Dict[str, Any]] = Field(default=[], description=\"Literature search results\")
    existing_references: List[Dict[str, Any]] = Field(default=[], description=\"Existing references\")
    target_style: str = Field(default=\"ama\", description=\"Citation style\")
    enable_doi_validation: bool = Field(default=True, description=\"Enable DOI validation\")
    enable_duplicate_detection: bool = Field(default=True, description=\"Enable duplicate detection\")
    enable_quality_assessment: bool = Field(default=True, description=\"Enable quality assessment\")
    enable_journal_recommendations: bool = Field(default=False, description=\"Enable journal recommendations\")
    max_references: Optional[int] = Field(None, description=\"Maximum references\")
    research_field: Optional[str] = Field(None, description=\"Research field\")
    target_journal: Optional[str] = Field(None, description=\"Target journal\")

class CollaborationSessionRequest(BaseModel):
    \"\"\"Request model for collaboration session.\"\"\"
    study_id: str = Field(..., description=\"Study identifier\")
    editor_id: str = Field(..., description=\"Editor identifier\")
    editor_name: str = Field(..., description=\"Editor name\")

class ReferenceEditRequest(BaseModel):
    \"\"\"Request model for reference edit.\"\"\"
    session_id: str = Field(..., description=\"Session identifier\")
    reference_id: str = Field(..., description=\"Reference identifier\")
    field_name: str = Field(..., description=\"Field being edited\")
    old_value: str = Field(..., description=\"Previous value\")
    new_value: str = Field(..., description=\"New value\")
    edit_type: str = Field(..., description=\"Edit type: add, modify, delete\")
    editor_id: str = Field(..., description=\"Editor identifier\")
    editor_name: str = Field(..., description=\"Editor name\")

class JournalRecommendationRequest(BaseModel):
    \"\"\"Request model for journal recommendations.\"\"\"
    references: List[Dict[str, Any]] = Field(..., description=\"Reference list\")
    manuscript_abstract: str = Field(default=\"\", description=\"Manuscript abstract\")
    research_field: str = Field(default=\"general\", description=\"Research field\")
    target_impact_range: List[float] = Field(default=[1.0, 100.0], description=\"Impact factor range\")
    open_access_preference: bool = Field(default=False, description=\"Open access preference\")

class JournalFitAnalysisRequest(BaseModel):
    \"\"\"Request model for journal fit analysis.\"\"\"
    journal_name: str = Field(..., description=\"Target journal name\")
    references: List[Dict[str, Any]] = Field(..., description=\"Reference list\")
    manuscript_abstract: str = Field(default=\"\", description=\"Manuscript abstract\")

# Initialize FastAPI app
app = FastAPI(
    title=\"Enhanced Reference Management API\",
    description=\"Advanced reference management system with AI-powered features\",
    version=\"1.0.0\"
)

@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    try:\n        monitor = await get_system_monitor()\n        status = await monitor.get_system_status_summary()\n        return {\n            \"status\": \"healthy\",\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"system_status\": status\n        }\n    except Exception as e:\n        raise HTTPException(status_code=503, detail=f\"System unhealthy: {str(e)}\")\n\n@app.get(\"/health/comprehensive\")\nasync def comprehensive_health_check():\n    \"\"\"Comprehensive health check endpoint.\"\"\"\n    try:\n        monitor = await get_system_monitor()\n        health_result = await monitor.comprehensive_health_check()\n        return health_result\n    except Exception as e:\n        raise HTTPException(status_code=503, detail=f\"Health check failed: {str(e)}\")\n\n@app.post(\"/references/process\")\nasync def process_references(request: ReferenceProcessingRequest):\n    \"\"\"Process references with enhanced features.\"\"\"\n    try:\n        # Convert request to ReferenceState\n        style_mapping = {\n            \"ama\": CitationStyle.AMA,\n            \"apa\": CitationStyle.APA,\n            \"vancouver\": CitationStyle.VANCOUVER,\n            \"harvard\": CitationStyle.HARVARD,\n            \"chicago\": CitationStyle.CHICAGO,\n            \"nature\": CitationStyle.NATURE,\n            \"cell\": CitationStyle.CELL,\n            \"jama\": CitationStyle.JAMA,\n            \"mla\": CitationStyle.MLA,\n            \"ieee\": CitationStyle.IEEE\n        }\n        \n        citation_style = style_mapping.get(request.target_style.lower(), CitationStyle.AMA)\n        \n        ref_state = ReferenceState(\n            study_id=request.study_id,\n            manuscript_text=request.manuscript_text,\n            literature_results=request.literature_results,\n            existing_references=[Reference(**ref) for ref in request.existing_references],\n            target_style=citation_style,\n            enable_doi_validation=request.enable_doi_validation,\n            enable_duplicate_detection=request.enable_duplicate_detection,\n            enable_quality_assessment=request.enable_quality_assessment,\n            max_references=request.max_references,\n            research_field=request.research_field,\n            target_journal=request.target_journal\n        )\n        \n        # Process references\n        ref_service = await get_reference_service()\n        result = await ref_service.process_references(ref_state)\n        \n        # Add journal recommendations if requested\n        journal_recommendations = []\n        citation_impact_analysis = {}\n        \n        if request.enable_journal_recommendations:\n            try:\n                journal_intel = await get_journal_intelligence()\n                journal_recommendations = await journal_intel.recommend_target_journals(\n                    result.references,\n                    request.manuscript_text,\n                    request.research_field or \"general\"\n                )\n                \n                citation_impact_analysis = await journal_intel.analyze_citation_impact(\n                    result.references\n                )\n            except Exception as e:\n                logger.warning(f\"Journal recommendations failed: {e}\")\n        \n        # Convert result to JSON serializable format\n        return {\n            \"success\": True,\n            \"study_id\": result.study_id,\n            \"references\": [ref.model_dump() for ref in result.references],\n            \"citations\": [citation.model_dump() for citation in result.citations],\n            \"bibliography\": result.bibliography,\n            \"citation_map\": result.citation_map,\n            \"quality_scores\": [score.model_dump() for score in result.quality_scores],\n            \"warnings\": [warning.model_dump() for warning in result.warnings],\n            \"total_references\": result.total_references,\n            \"style_compliance_score\": result.style_compliance_score,\n            \"processing_time_seconds\": result.processing_time_seconds,\n            \"journal_recommendations\": journal_recommendations,\n            \"citation_impact_analysis\": citation_impact_analysis\n        }\n        \n    except Exception as e:\n        logger.error(f\"Reference processing failed: {e}\", exc_info=True)\n        raise HTTPException(status_code=500, detail=f\"Processing failed: {str(e)}\")\n\n@app.post(\"/collaboration/session/start\")\nasync def start_collaboration_session(request: CollaborationSessionRequest):\n    \"\"\"Start a collaborative editing session.\"\"\"\n    try:\n        collab_manager = await get_collaborative_manager()\n        session_id = await collab_manager.start_session(\n            request.study_id,\n            request.editor_id,\n            request.editor_name\n        )\n        \n        return {\n            \"success\": True,\n            \"session_id\": session_id,\n            \"study_id\": request.study_id,\n            \"started_by\": request.editor_name\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to start collaboration session: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Session start failed: {str(e)}\")\n\n@app.post(\"/collaboration/session/{session_id}/join\")\nasync def join_collaboration_session(session_id: str, request: CollaborationSessionRequest):\n    \"\"\"Join an existing collaborative editing session.\"\"\"\n    try:\n        collab_manager = await get_collaborative_manager()\n        success = await collab_manager.join_session(\n            session_id,\n            request.editor_id,\n            request.editor_name\n        )\n        \n        if not success:\n            raise HTTPException(status_code=404, detail=\"Session not found\")\n        \n        return {\n            \"success\": True,\n            \"session_id\": session_id,\n            \"joined_by\": request.editor_name\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to join collaboration session: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Session join failed: {str(e)}\")\n\n@app.post(\"/collaboration/session/{session_id}/lock/{reference_id}\")\nasync def request_reference_lock(session_id: str, reference_id: str, editor_id: str, editor_name: str):\n    \"\"\"Request lock on a reference for editing.\"\"\"\n    try:\n        collab_manager = await get_collaborative_manager()\n        result = await collab_manager.request_reference_lock(\n            session_id,\n            reference_id,\n            editor_id,\n            editor_name\n        )\n        \n        return result\n        \n    except Exception as e:\n        logger.error(f\"Failed to request reference lock: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Lock request failed: {str(e)}\")\n\n@app.delete(\"/collaboration/session/{session_id}/lock/{reference_id}\")\nasync def release_reference_lock(session_id: str, reference_id: str, editor_id: str, editor_name: str):\n    \"\"\"Release lock on a reference.\"\"\"\n    try:\n        collab_manager = await get_collaborative_manager()\n        success = await collab_manager.release_reference_lock(\n            session_id,\n            reference_id,\n            editor_id,\n            editor_name\n        )\n        \n        return {\n            \"success\": success,\n            \"reference_id\": reference_id,\n            \"released_by\": editor_name\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to release reference lock: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Lock release failed: {str(e)}\")\n\n@app.post(\"/collaboration/session/{session_id}/edit\")\nasync def apply_reference_edit(session_id: str, request: ReferenceEditRequest):\n    \"\"\"Apply an edit to a reference.\"\"\"\n    try:\n        collab_manager = await get_collaborative_manager()\n        \n        edit = ReferenceEdit(\n            edit_id=\"\",  # Will be generated\n            reference_id=request.reference_id,\n            field_name=request.field_name,\n            old_value=request.old_value,\n            new_value=request.new_value,\n            editor_id=request.editor_id,\n            editor_name=request.editor_name,\n            timestamp=datetime.utcnow(),\n            edit_type=request.edit_type\n        )\n        \n        result = await collab_manager.apply_reference_edit(session_id, edit)\n        \n        return result\n        \n    except Exception as e:\n        logger.error(f\"Failed to apply reference edit: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Edit failed: {str(e)}\")\n\n@app.get(\"/collaboration/session/{session_id}/status\")\nasync def get_session_status(session_id: str):\n    \"\"\"Get collaborative session status.\"\"\"\n    try:\n        collab_manager = await get_collaborative_manager()\n        status = await collab_manager.get_session_status(session_id)\n        \n        if not status:\n            raise HTTPException(status_code=404, detail=\"Session not found\")\n        \n        return status\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to get session status: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Status retrieval failed: {str(e)}\")\n\n@app.get(\"/collaboration/session/{session_id}/history/{reference_id}\")\nasync def get_reference_edit_history(session_id: str, reference_id: str):\n    \"\"\"Get edit history for a reference.\"\"\"\n    try:\n        collab_manager = await get_collaborative_manager()\n        history = await collab_manager.get_reference_edit_history(session_id, reference_id)\n        \n        return {\n            \"reference_id\": reference_id,\n            \"edit_history\": history\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to get edit history: {e}\")\n        raise HTTPException(status_code=500, detail=f\"History retrieval failed: {str(e)}\")\n\n@app.post(\"/journal/recommendations\")\nasync def get_journal_recommendations(request: JournalRecommendationRequest):\n    \"\"\"Get journal recommendations based on references.\"\"\"\n    try:\n        journal_intel = await get_journal_intelligence()\n        \n        # Convert dict references to Reference objects\n        references = [Reference(**ref_data) for ref_data in request.references]\n        \n        recommendations = await journal_intel.recommend_target_journals(\n            references,\n            request.manuscript_abstract,\n            request.research_field,\n            tuple(request.target_impact_range),\n            request.open_access_preference\n        )\n        \n        return {\n            \"success\": True,\n            \"recommendations\": recommendations\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to generate journal recommendations: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Recommendations failed: {str(e)}\")\n\n@app.post(\"/journal/impact-analysis\")\nasync def analyze_citation_impact(references: List[Dict[str, Any]]):\n    \"\"\"Analyze citation impact of references.\"\"\"\n    try:\n        journal_intel = await get_journal_intelligence()\n        \n        # Convert dict references to Reference objects\n        ref_objects = [Reference(**ref_data) for ref_data in references]\n        \n        analysis = await journal_intel.analyze_citation_impact(ref_objects)\n        \n        return {\n            \"success\": True,\n            \"impact_analysis\": analysis\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to analyze citation impact: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Impact analysis failed: {str(e)}\")\n\n@app.post(\"/journal/fit-analysis\")\nasync def analyze_journal_fit(request: JournalFitAnalysisRequest):\n    \"\"\"Analyze manuscript fit for a specific journal.\"\"\"\n    try:\n        journal_intel = await get_journal_intelligence()\n        \n        # Convert dict references to Reference objects\n        references = [Reference(**ref_data) for ref_data in request.references]\n        \n        analysis = await journal_intel.analyze_journal_fit(\n            request.journal_name,\n            references,\n            request.manuscript_abstract\n        )\n        \n        return {\n            \"success\": True,\n            \"fit_analysis\": analysis\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to analyze journal fit: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Fit analysis failed: {str(e)}\")\n\n@app.get(\"/monitoring/performance\")\nasync def get_performance_report(hours: int = 24):\n    \"\"\"Get system performance report.\"\"\"\n    try:\n        monitor = await get_system_monitor()\n        report = await monitor.generate_performance_report(hours)\n        \n        return report\n        \n    except Exception as e:\n        logger.error(f\"Failed to generate performance report: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Performance report failed: {str(e)}\")\n\n@app.get(\"/monitoring/metrics\")\nasync def get_current_metrics():\n    \"\"\"Get current system metrics.\"\"\"\n    try:\n        monitor = await get_system_monitor()\n        metrics = await monitor.collect_performance_metrics()\n        \n        return {\n            \"timestamp\": metrics.timestamp.isoformat(),\n            \"metrics\": {\n                \"response_time_ms\": metrics.average_response_time_ms,\n                \"cache_hit_rate\": metrics.cache_hit_rate,\n                \"error_rate\": metrics.error_rate,\n                \"memory_usage_mb\": metrics.memory_usage_mb,\n                \"cpu_usage_percent\": metrics.cpu_usage_percent\n            }\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to get metrics: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Metrics collection failed: {str(e)}\")\n\n@app.post(\"/system/deploy\")\nasync def deploy_system(background_tasks: BackgroundTasks, config: Optional[Dict[str, Any]] = None):\n    \"\"\"Deploy the enhanced reference management system.\"\"\"\n    try:\n        # Run deployment in background\n        background_tasks.add_task(deploy_enhanced_reference_system, config)\n        \n        return {\n            \"success\": True,\n            \"message\": \"Deployment started in background\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to start deployment: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Deployment failed: {str(e)}\")\n\n@app.get(\"/system/validate\")\nasync def validate_system():\n    \"\"\"Validate system deployment.\"\"\"\n    try:\n        validation_result = await validate_system_deployment()\n        \n        return {\n            \"success\": True,\n            \"validation_result\": validation_result\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to validate system: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Validation failed: {str(e)}\")\n\n@app.get(\"/stats\")\nasync def get_system_stats():\n    \"\"\"Get comprehensive system statistics.\"\"\"\n    try:\n        # Collect stats from all components\n        stats = {}\n        \n        try:\n            ref_service = await get_reference_service()\n            stats['reference_service'] = await ref_service.get_stats()\n        except:\n            stats['reference_service'] = {'error': 'Service not available'}\n        \n        try:\n            journal_intel = await get_journal_intelligence()\n            stats['journal_intelligence'] = await journal_intel.get_stats()\n        except:\n            stats['journal_intelligence'] = {'error': 'Service not available'}\n        \n        try:\n            monitor = await get_system_monitor()\n            stats['system_status'] = await monitor.get_system_status_summary()\n        except:\n            stats['system_status'] = {'error': 'Monitoring not available'}\n        \n        return {\n            \"success\": True,\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"stats\": stats\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to get system stats: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Stats collection failed: {str(e)}\")\n\nif __name__ == \"__main__\":\n    # Run the API server\n    uvicorn.run(\n        \"api_endpoints:app\",\n        host=\"0.0.0.0\",\n        port=8001,\n        reload=True,\n        log_level=\"info\"\n    )